---
title: "Toy Projects"
date: 2018-04-15T00:08:39-04:00
tags: ['toy projects']
draft: true
---

I like the idea of a project that is the least amount of work you can do to learn about a single concept.  Such a project represents a chunk of knowledge that you build, be it JavaScript syntax you can test quickly on the command line, a small project to help you understand inputs and outputs in python, or building a web application to introduce you to the full stack and architecture behind a simple project.

I hesitate to appropriate any existing buzzwords or even attempt to create a new one.  If you think about the chunk that teaches you about it as a product, this does represent a minimum viable product.  More of a minimum viable project, really.  Better yet, a single use toy project.  This isn't something you'd use for anything that depended on your ability to buy food, such as showing it off to potential employers or using it on your production web server, but more something created for the purpose of understanding a concept.

That being said, I find it greatly helps to have motivation outside of just doing-to-learn to learn something, such as having to complete something for a class assignment or completing something for your day job so you can afford to buy food next month too.

My favorite thing about computer science is the lack of limitations about what you can build.  I greatly enjoy this section from the [first MIT OCW SICP lecture](https://youtu.be/2Op3QLzMgSY?t=7m19s):

>OK, so in computer science, we're in the business of formalizing this sort of how-to imperative knowledge, how to do stuff. And the real issues of computer science are, of course, not telling people how to do square roots. Because if that was all it was, there wouldn't be no big deal. The real problems come when we try to build very, very large systems, computer programs that are thousands of pages long, so long that nobody can really hold them in their heads all at once.
>
>And the only reason that that's possible is because there are techniques for controlling the complexity of these large systems. And these techniques that are controlling complexity are what this course is really about. And in some sense, that's really what computer science is about.
>
>Now, that may seem like a very strange thing to say. Because after all, a lot of people besides computer scientists deal with controlling complexity. A large airliner is an extremely complex system, and the aeronautical engineers who design that are dealing with immense complexity. But there's a difference between that kind of complexity and what we deal with in computer science.
>
>And that is that computer science, in some sense, isn't real. You see, when an engineer is designing a physical system, that's made out of real parts. The engineers who worry about that have to address problems of tolerance and approximation and noise in the system. So for example, as an electrical engineer, I can go off and easily build a one-stage amplifier or a two-stage amplifier, and I can imagine cascading a lot of them to build a million-stage amplifier. But it's ridiculous to build such a thing, because long before the millionth stage, the thermal noise in those components way at the beginning is going to get amplified and make the whole thing meaningless.
>
>Computer science deals with idealized components. We know as much as we want about these little program and data pieces that we're fitting things together. We don't have to worry about tolerance. And that means that, in building a large program, there's not all that much difference between what I can build and what I can imagine, because the parts are these abstract entities that I know as much as I want.
>
>So as opposed to other kinds of engineering where the constraints on what you can build are the constraints of physical systems, the constraints of physics and noise and approximation. The constraints imposed in building large software systems are the limitations of our own minds.

The only constraints are the limitations of our own minds.  If you can imagine it and figure out a way to implement it, you can build it.

